<!DOCTYPE html>
<html>
<head>
  <style>
    * { margin: 0; padding: 0; }
    body { background: #1a1a2e; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
  <script>
    // 图片特效着色器
    const vertexShader = `
      varying vec2 vUv;
      uniform float uTime;

      void main() {
        vUv = uv;
        vec3 pos = position;

        // 波浪变形
        pos.z += sin(pos.x * 3.0 + uTime) * 0.05;
        pos.z += cos(pos.y * 2.0 + uTime * 0.8) * 0.03;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `;

    const fragmentShader = `
      varying vec2 vUv;
      uniform float uTime;
      uniform vec2 uResolution;

      // 生成渐变图案作为测试图像
      vec3 generatePattern(vec2 uv) {
        vec3 col = vec3(0.0);

        // 渐变背景
        col = mix(vec3(0.1, 0.2, 0.4), vec3(0.3, 0.1, 0.3), uv.y);

        // 圆形图案
        for (float i = 0.0; i < 5.0; i++) {
          vec2 center = vec2(
            0.2 + i * 0.15,
            0.5 + sin(i * 1.5) * 0.2
          );
          float d = length(uv - center);
          float circle = smoothstep(0.08, 0.07, d);
          vec3 circleColor = vec3(
            0.5 + 0.5 * sin(i * 1.0),
            0.5 + 0.5 * sin(i * 1.5 + 2.0),
            0.5 + 0.5 * sin(i * 2.0 + 4.0)
          );
          col = mix(col, circleColor, circle);
        }

        // 条纹
        float stripe = smoothstep(0.48, 0.5, abs(sin(uv.x * 30.0)));
        col = mix(col, col * 1.2, stripe * 0.3);

        return col;
      }

      // 灰度效果
      vec3 grayscale(vec3 color) {
        float gray = dot(color, vec3(0.299, 0.587, 0.114));
        return vec3(gray);
      }

      // 亮度对比度
      vec3 brightnessContrast(vec3 color, float brightness, float contrast) {
        color += brightness;
        color = (color - 0.5) * contrast + 0.5;
        return color;
      }

      // 色相偏移 (简化版)
      vec3 hueShift(vec3 color, float shift) {
        float angle = shift * 6.28318;
        float s = sin(angle);
        float c = cos(angle);
        mat3 rot = mat3(
          0.299 + 0.701*c - 0.299*s,  0.587 - 0.587*c - 0.587*s,  0.114 - 0.114*c + 0.886*s,
          0.299 - 0.299*c + 0.143*s,  0.587 + 0.413*c + 0.143*s,  0.114 - 0.114*c - 0.286*s,
          0.299 - 0.299*c - 0.701*s,  0.587 - 0.587*c + 0.587*s,  0.114 + 0.886*c + 0.114*s
        );
        return rot * color;
      }

      // 像素化
      vec2 pixelate(vec2 uv, float pixels) {
        float dx = 1.0 / pixels;
        return floor(uv / dx) * dx + dx * 0.5;
      }

      // 波浪扭曲
      vec2 wave(vec2 uv, float time) {
        uv.x += sin(uv.y * 10.0 + time) * 0.02;
        uv.y += cos(uv.x * 8.0 + time * 0.8) * 0.015;
        return uv;
      }

      // 晕影效果
      float vignette(vec2 uv) {
        uv = uv * 2.0 - 1.0;
        return 1.0 - dot(uv * 0.5, uv * 0.5);
      }

      // RGB分离
      vec3 rgbShift(vec2 uv, float amount) {
        vec2 dir = normalize(uv - 0.5);
        vec3 col;
        col.r = generatePattern(uv + dir * amount).r;
        col.g = generatePattern(uv).g;
        col.b = generatePattern(uv - dir * amount).b;
        return col;
      }

      void main() {
        vec2 uv = vUv;

        // 将画面分成6个区域展示不同效果
        float section = floor(uv.x * 3.0) + floor(uv.y * 2.0) * 3.0;
        vec2 localUv = fract(uv * vec2(3.0, 2.0));

        vec3 color;

        if (section < 0.5) {
          // 原始图案
          color = generatePattern(localUv);
        } else if (section < 1.5) {
          // 波浪扭曲
          vec2 waveUv = wave(localUv, uTime * 2.0);
          color = generatePattern(waveUv);
        } else if (section < 2.5) {
          // 像素化
          float pixels = 20.0 + sin(uTime) * 10.0;
          vec2 pixelUv = pixelate(localUv, pixels);
          color = generatePattern(pixelUv);
        } else if (section < 3.5) {
          // 灰度
          color = grayscale(generatePattern(localUv));
        } else if (section < 4.5) {
          // 色相偏移
          color = hueShift(generatePattern(localUv), uTime * 0.1);
        } else {
          // RGB分离
          float shift = sin(uTime) * 0.02 + 0.01;
          color = rgbShift(localUv, shift);
        }

        // 添加网格分隔线
        float gridX = smoothstep(0.01, 0.0, abs(fract(uv.x * 3.0)));
        float gridY = smoothstep(0.02, 0.0, abs(fract(uv.y * 2.0)));
        color = mix(color, vec3(0.3), max(gridX, gridY));

        // 晕影
        color *= vignette(uv) * 0.5 + 0.7;

        gl_FragColor = vec4(color, 1.0);
      }
    `;

    // 场景初始化
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, innerWidth / innerHeight, 0.1, 100);
    camera.position.z = 2;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // 创建平面
    const geometry = new THREE.PlaneGeometry(3, 2, 32, 32);
    const material = new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms: {
        uTime: { value: 0 },
        uResolution: { value: new THREE.Vector2(innerWidth, innerHeight) }
      }
    });

    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    // 动画
    function animate() {
      requestAnimationFrame(animate);
      material.uniforms.uTime.value += 0.016;
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      material.uniforms.uResolution.value.set(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
